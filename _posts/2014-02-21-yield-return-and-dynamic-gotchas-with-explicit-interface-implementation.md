---
title: Yield return and dynamic gotchas with explicit interface implementation
date: 2014-02-21 22:04
category: 
author: 
tags: [programming, .net]
summary: 
---

<p style="text-align: justify;">This week while I'm doing a little demo to measure the time using a yield return method vs return a static list.&nbsp;I decided to use the keyword <span style="color: #0000ff;">dynamic&nbsp;</span>to simplify my code and avoid &nbsp;the methods overload. Quickly i found when I called the yield return method it simple crashed with a kinda gotchas between&nbsp;<span style="color: #0000ff;">dynamic<span style="color: #000000;"> and&nbsp;<span style="color: #0000ff;">IEnumerable&lt;T&gt;. <span style="color: #000000;">It fails when yield code explicitly implements its interfaces. The solution is to help the&nbsp;execution-time overload resolution to find the most specific method.&nbsp;</span></span></span></span></p>
Code demo:
<pre class="brush: csharp;">using System;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;

namespace YieldDemo
{
    public class States1
    {
          public static IEnumerable&lt;string&gt; GetNames()
        {
            yield return "Alabama";
            yield return "Alaska";
            yield return "Arizona";
            yield return "Arkansas";
            yield return "California";
            yield return "Others ...";
        }
    }

    public class States2
    {
        private static readonly IList&lt;string&gt; _names;

        static States2()
        {
            _names = new List&lt;string&gt;() {"Alabama", 
                                     "Alaska",
                                     "Arizona",
                                     "Arkansas",
                                     "California",
                                     "Others ..." };

        }

        public static IList&lt;string&gt; GetNames()
        {
            return _names;
        }
    }

    public class Program
    {

        static void Main()
        {
            Test(States2.GetNames());
            Test(States1.GetNames());

            Console.ReadLine();
        }

        public static void Test(dynamic state)
        {
            Stopwatch stopwatch = new Stopwatch();

            stopwatch.Start();
            Iterate(state);            
            stopwatch.Stop();

            Console.WriteLine("Time elapsed: {0}", stopwatch.Elapsed);
        }

        public static void Iterate(dynamic itemList)
        {
            var enumerator = itemList.GetEnumerator();

            while (enumerator.MoveNext())
            {
                Console.WriteLine(enumerator.Current);
            }
        }
    }
}</pre>
When i call the following method:
<pre class="brush: csharp;">Test(States1.GetNames())</pre>
I received the error&nbsp;"Additional information: 'object' does not contain a definition for 'GetEnumerator'".

Without any clue why this is happening. I posted a question in <a title="StackOverflow" href="http://stackoverflow.com/questions/21915935/yield-return-and-dynamic" target="_blank">StackOverflow</a>&nbsp;and I got some help.
<blockquote>"The problem is that the iterator block implementation uses&nbsp;<em>explicit interface implementation</em>&nbsp;to implement&nbsp;<code>IEnumerable&lt;T&gt;</code>... and explicit interface implementation doesn't play nicely with dynamic typing in general. (You don't need to use iterator blocks to see that. See&nbsp;<a href="http://csharpindepth.com/Articles/Chapter14/DynamicGotchas.aspx" rel="nofollow">my article on Gotchas in Dynamic Typing</a>&nbsp;for more details.)"

"It fails because the&nbsp;<code>IEnumerable&lt;string&gt;</code>&nbsp;class generated by your&nbsp;<code>yield</code>&nbsp;code&nbsp;<a href="http://msdn.microsoft.com/en-us/library/ms173157.aspx" rel="nofollow">explicitly implements</a>&nbsp;its interfaces (including the&nbsp;<code>GetEnumerator</code>&nbsp;you're trying to use)."</blockquote>
So ...
<blockquote>One way of avoiding the explicit interface implementation issue is to use dynamic typing to perform execution-time overload resolution to find the most specific method ... the compiler won't always know which overload to choose.</blockquote>
Solution 1:

Using the foreach to iterate.
<pre class="brush: csharp;">public static void Iterate(dynamic itemList)
{
    foreach (dynamic item in itemList)
    {
        Console.WriteLine(item);
    }
}</pre>
Solution 2:
<pre class="brush: csharp;">public static void Iterate(dynamic itemList)
{
    var enumerator = ((IEnumerable)itemList).GetEnumerator();

    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
}</pre>
Solution 3:
<pre class="brush: csharp;">public static void Iterate(IEnumerable itemList)
{
    var enumerator = itemList.GetEnumerator();

    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
}</pre>
Solution 4:
<pre class="brush: csharp;">public static void Iterate&lt;T&gt;(IEnumerable&lt;T&gt; itemList)
{
    var enumerator = itemList.GetEnumerator();

    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
}</pre>